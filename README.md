#Algorithm Implementations

(Note: there is a backstory on my motivation for starting this at the bottom of this README)

Website coming soon!

**Update 12/30/13:** I have given the 3 top committers (jcla1, PatrickYevsukov, dalleng) collaborator access. This was very well earned, as they have managed to contribute much more to this repo than I have had the time to.

Again, thanks so much for the consistency guys, it is extremely appreciated. It made sense to start with giving these guys collab access for obvious reasons, but I also thank every single person who has even submitted a pull request. Without you all, this repository would be nothing.

To do my part more, I am now working on a web application that will tie things up in a much more fluid way, and help exhibit the algorithms to those who either don't know much about git/github, or just can't be vexed clicking through all the folders. This will open the repo up to a much wider audience in general!

Purpose
----------
We see tons of interesting projects that are actively contributed to here on Github. Seriously, it's very powerful.

Unfortunately, I haven't really spotted (a popular and language agnostic) one where people used the power of Git to share, discover, discuss and improve algorithm implementations!

***Send us a pull request, and we will add any implementation of any algorithm you have so long as it at least mostly suits the following conventions.***

Conventions
-----------

+ Language doesn't matter. Just make sure you're implementing an algorithm.
+ Submissions should follow this directory structure

		Algorithm_Name/Language_Name/username/filename.extension
		Algorithm_Name/Language_Name/username/filename_test.extension

+ When implementing a new algorithm, create a "tags" file in the algorithm's root directory and add some appropriate tags
+ Please package your code in a directory bearing your GitHub username. `git blame` is cool, and has many more appropriate applications, but in this context I'd rather pull a flat list of files and be able to check out everyone's contributions that way than have to look through the revisions.

+ Each algorithm should have its corresponding unit test cases (as directory structure suggested above) which covers the corner cases, happy/unhappy paths.

	The advantage of doing so is to assert that everything is covered, and that the algorithm is not broken between code changes.

	It also helps newbies to have a quick look at the unit test cases to understand the basic usecase of the algorithm.

+ Documentation inside the code is recommended. This helps others in understanding the code base.

+ Have fun!

Resources
---------
We should also keep a curated list of resources dealing with algorithms.

####Introductory Books
+ [Introduction to Algorithms](http://www.amazon.com/Introduction-Algorithms-Second-Edition-Thomas/dp/0262032937) (CLRS)
+ [Algorithms](http://www.amazon.com/Algorithms-Sanjoy-Dasgupta/dp/0073523402) (Dasgupta, Papadimitriou, and Vazirani)
+ [The Algorithm Design Manual](http://www.amazon.com/Algorithm-Design-Manual-Steve-Skiena/dp/0387948600) (Steven Skiena)
+ [Algorithms, 4th Edition](http://algs4.cs.princeton.edu/home/) (Robert Sedgewick, Kevin Wayne)


####Sites
+ [LiteratePrograms](http://en.literateprograms.org/LiteratePrograms:Welcome) (TONS of code samples in various problem domains)
+ [UVa Online Judge](http://uva.onlinejudge.org) (TONS of problems to solve, automatic judging)
+ [Stony Brook Algorithm Repository](http://www.cs.sunysb.edu/~algorith/)
+ [The Archive of Interesting Code](http://www.keithschwarz.com/interesting/)
+ [ACM Collected Algorithms(CALGO)](http://calgo.acm.org)

####Online Classes
+ [Algorithms Part I - Coursera](https://www.coursera.org/course/algs4partI)
+ [Algorithms Part II - Coursera](https://www.coursera.org/course/algs4partII)
+ [Algorithms: Design and Analysis, Part 1 - Coursera](https://www.coursera.org/course/algo)
+ [Algorithms: Design and Analysis, Part 2 - Coursera](https://www.coursera.org/course/algo2)


Backstory
---------
I have been "***coding***" since I was about 12, and have been teaching myself **software engineering** principles through solving problems in various languages through practice, freelance work and my own projects.

But, you see, it wasn't until a couple of years ago in high school when I started to truly see the light about how languages are merely *tools*; I basically realized what is common sense to me now - to truly be able to call one's self a *proficient* programmer, one must go beyond simple syntax slinging and be capable of efficiently solving a much wider subset of problems within computer programming than the *average* programmer.

Of course, this was merely one of the initial revelations that led to the revelation that ultimately led to this repository.


When I decided to become a Computer Science major, I took the initiative to research actual **Computer Science** topics, outside of class, as I've always been more of a self-learner.

 Lo and behold, CS and practical software engineering turned out to be two entirely different things.

I won't go into my whole journey up til this point in this README, but tl;dr:

**There are many problem domains which are simply closed off to the programmer who stagnates in his learning and never studies how to analyze algorithms and develop his own. This is objectively true.**


I also have a much greater level of respect towards my profession now, and take it very seriously. I have a relatively rigorous base education roadmap that I've laid out for myself. Even being just a core subset of skills from which I will base subsequently developed skills on, it's quite expansive and diverse. I do not plan on stagnating, ever.



[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/kennyledet/algorithm-implementations/trend.png)](https://bitdeli.com/free "Bitdeli Badge")

